TITLE:: QDTSSolver
summary:: Newton solver for Quadratic Distortion Tone Spectra synthesis
categories:: UGens>Generators>Deterministic, UGens>Analysis
related:: Classes/QDTS, Guides/QDTS_Guide

DESCRIPTION::
QDTSSolver is a UGen that solves a system of nonlinear equations for synthesizing Auditory Distortion Products (ADPs). It uses Newton's method with random restarts to find amplitude coefficients that produce a desired harmonic spectrum through quadratic distortion.

Based on:

Gutiérrez, E., Haworth, C., and Cádiz, R. (2024). emphasis::"Generating Sonic Phantoms with Quadratic Difference Tone Spectrum Synthesis.":: Computer Music Journal 47(3):1-16.

Kendall, G.S., Haworth, C., and Cádiz, R.F. (2014). emphasis::"Sound Synthesis with Auditory Distortion Products.":: Computer Music Journal 38(4).

The solver runs at control rate and outputs normalized amplitude values that can be used to scale sinusoidal oscillators.

WARNING:: Avoid setting target values to exactly 0, as this can cause solver instability and produce loud output. Always use code::target.max(0.01):: or similar clamping.

SUBSECTION:: Target Value Range

Target values represent emphasis::relative:: amplitude ratios for the desired harmonic spectrum:

LIST::
## strong::Minimum::: Must be > 0 (use 0.01 as safe minimum)
## strong::Maximum::: No strict upper limit, but typical range is 0.01 to 2.0
## strong::Normalization::: Output amplitudes are normalized by the solver
::

Common spectral shapes:
LIST::
## code::[1, 0.5, 0.33, 0.25]:: - Sawtooth-like (1/n rolloff)
## code::[1, 0.01, 0.5, 0.01]:: - Square-ish (odd harmonics)
## code::[0.5, 1, 0.5, 0.25]:: - 2nd harmonic dominant
## code::[1, 1, 1, 1]:: - Equal harmonics (bright/harsh)
## code::[1, 0.1, 0.05, 0.02]:: - Mellow/sine-like
::

CLASSMETHODS::

METHOD:: kr
Solve for amplitude coefficients at control rate.

ARGUMENT:: numHarmonics
The number of target harmonics to solve for. Must be between 1 and 16.

ARGUMENT:: ... targets
Variable number of target harmonic amplitudes. The number of targets should match numHarmonics.

returns::
An Array of code::numHarmonics + 2:: values:
LIST::
## code::[0]:: to code::[numHarmonics]:: - Solved amplitude coefficients (normalized)
## code::[numHarmonics + 1]:: - Estimation error (lower values indicate better convergence)
::

INSTANCEMETHODS::

private:: init, checkInputs


EXAMPLES::

SUBSECTION:: Basic Usage

code::
// Boot server first
s.boot;

// Simple test - verify outputs
(
{
    var targets = [1, 0.5, 0.33, 0.25];
    var sig = QDTSSolver.kr(4, *targets);
    sig.poll(2);
    Silent.ar;
}.play;
)
// Outputs: [amp0, amp1, amp2, amp3, amp4, error]
::

SUBSECTION:: Basic Synthesis

code::
// Synthesize with carrier and target pitch
(
{
    var numPartials = 4;
    var carrierPitch = 1000;
    var targetPitch = 100;
    var targets = [1, 0.5, 0.33, 0.25];

    var amps = QDTSSolver.kr(numPartials, *targets);
    var freqs = (numPartials + 1).collect {|i| carrierPitch + (i * targetPitch) };
    var sines = (numPartials + 1).collect {|i| SinOsc.ar(freqs[i]) * amps[i] };

    sines.sum * 0.2 ! 2
}.play;
)
::

SUBSECTION:: SynthDef with Envelope

code::
(
SynthDef(\qdtsEnv, {|out = 0, carrierPitch = 1280, targetPitch = 130,
    amp = 0.2, gate = 1, atk = 0.01, dec = 0.1, sus = 0.7, rel = 0.5,
    t0 = 1, t1 = 0.5, t2 = 0.33, t3 = 0.25|

    // Clamp targets to avoid instability
    var t0s = t0.max(0.01);
    var t1s = t1.max(0.01);
    var t2s = t2.max(0.01);
    var t3s = t3.max(0.01);

    var env = EnvGen.kr(Env.adsr(atk, dec, sus, rel), gate, doneAction: 2);
    var amps = QDTSSolver.kr(4, t0s, t1s, t2s, t3s);
    var freqs = 5.collect {|i| carrierPitch + (i * targetPitch) };
    var sines = 5.collect {|i| SinOsc.ar(freqs[i]) * amps[i] };

    Out.ar(out, Limiter.ar(sines.sum * env * amp, 0.9) ! 2);
}).add;
)

// Test
x = Synth(\qdtsEnv, [\carrierPitch, 1000, \targetPitch, 100]);
x.set(\gate, 0); // Release
::

SUBSECTION:: Real-time Spectrum Morphing

code::
(
SynthDef(\qdtsDynamic, {|out = 0, carrierPitch = 1280, targetPitch = 130, amp = 0.2,
    t0 = 1, t1 = 0.5, t2 = 0.33, t3 = 0.25|

    var amps = QDTSSolver.kr(4, t0.max(0.01), t1.max(0.01), t2.max(0.01), t3.max(0.01));
    var freqs = 5.collect {|i| carrierPitch + (i * targetPitch) };
    var sines = 5.collect {|i| SinOsc.ar(freqs[i]) * amps[i] };

    Out.ar(out, Limiter.ar(sines.sum * amp, 0.9) ! 2);
}).add;
)

x = Synth(\qdtsDynamic);

// Morph between spectra
x.set(\t0, 1, \t1, 0.01, \t2, 0.5, \t3, 0.01);  // Square-ish
x.set(\t0, 1, \t1, 0.5, \t2, 0.33, \t3, 0.25);  // Sawtooth
x.set(\t0, 1, \t1, 0.1, \t2, 0.05, \t3, 0.02);  // Mellow

x.free;
::

SUBSECTION:: Pattern Example

code::
(
SynthDef(\qdtsEnv, {|out = 0, carrierPitch = 1280, targetPitch = 130,
    amp = 0.2, gate = 1, atk = 0.01, dec = 0.1, sus = 0.7, rel = 0.5,
    t0 = 1, t1 = 0.5, t2 = 0.33, t3 = 0.25|

    var t0s = t0.max(0.01), t1s = t1.max(0.01);
    var t2s = t2.max(0.01), t3s = t3.max(0.01);

    var env = EnvGen.kr(Env.adsr(atk, dec, sus, rel), gate, doneAction: 2);
    var amps = QDTSSolver.kr(4, t0s, t1s, t2s, t3s);
    var freqs = 5.collect {|i| carrierPitch + (i * targetPitch) };
    var sines = 5.collect {|i| SinOsc.ar(freqs[i]) * amps[i] };

    Out.ar(out, Limiter.ar(sines.sum * env * amp, 0.9) ! 2);
}).add;
)

(
Pdef(\qdtsPattern,
    Pbind(
        \instrument, \qdtsEnv,
        \dur, Pseq([0.25, 0.25, 0.5, 0.25, 0.25, 0.25, 0.25], inf),
        \carrierPitch, Pseq([800, 1000, 1200, 1600], inf),
        \targetPitch, Pwhite(60, 150),
        \amp, 0.15,
        \atk, 0.01,
        \dec, 0.1,
        \sus, 0.6,
        \rel, 0.3,
        \t0, 1,
        \t1, Pwhite(0.2, 0.8),
        \t2, Pwhite(0.1, 0.5),
        \t3, Pwhite(0.05, 0.3),
    )
).play;
)

Pdef(\qdtsPattern).stop;
::

SUBSECTION:: LFO-Modulated Spectrum

code::
(
SynthDef(\qdtsLFO, {|out = 0, carrierPitch = 1280, targetPitch = 130, amp = 0.2|
    var t0 = LFNoise1.kr(0.5).range(0.5, 1);
    var t1 = LFNoise1.kr(0.3).range(0.1, 0.8);
    var t2 = LFNoise1.kr(0.4).range(0.05, 0.5);
    var t3 = LFNoise1.kr(0.2).range(0.02, 0.3);

    var amps = QDTSSolver.kr(4, t0, t1, t2, t3);
    var freqs = 5.collect {|i| carrierPitch + (i * targetPitch) };
    var sines = 5.collect {|i| SinOsc.ar(freqs[i]) * amps[i] };

    Out.ar(out, Limiter.ar(sines.sum * amp, 0.9) ! 2);
}).add;
)

y = Synth(\qdtsLFO);
y.set(\carrierPitch, 1000, \targetPitch, 80);
y.free;
::
